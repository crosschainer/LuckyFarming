# The basic idea:
# People deposit their https://swop.fi lp tokens
# They are put to farm on swop.fi (dapp-to-dapp)
# At a certain threshold (thresholdSwopRewards) of harvestable rewards they get claimed (dapp-to-dapp)
# One random guy that has pool tokens locked gets the full rewards of all deposited lp tokens (it will happen pretty often anyways so 1 is enough and no one is losing anything anyway)
# Happy people every couple minutes! <3

{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let lpAsset = base58'Btw3G1j4wQgdp49PTxaFkNvn75dQtqGDM7ejQppHnWC1'
let rewardAsset = base58'Ehie5xYpeN8op1Cctc6aGUrqx8jq3jtf1DSjXDbfm7aT'
let depositFee = 0
let keyActive = "active"
let isActive = this.getBooleanValue(keyActive)
let keyUserCount = "users"
let currentUserCount = this.getIntegerValue(keyUserCount)
let keyUserList = "userslist"
let currentUserList = this.getStringValue(keyUserList)
let adminPubKey = base58'DXDY2itiEcYBtGkVLnkpHtDFyWQUkoLJz79uJ7ECbMrA'
let swopPool = base58'3PHaNgomBkrvEL2QnuJarQVJa71wjw9qiqG'
let swopFarmingContract = Address(base58'3P73HDkPqG15nLXevjCbmXtazHYTZbpPoPw')
let thresholdSwopRewards = 1
let maxPoolUsers = 100 #This is because of string limitation on currentUserList, it can only fit a little over 100 users and need these for randomization
let dAppAddress = this


# Someone needs to execute this, dont know how to do it differently
@Callable(i)
func distributeLuckyRewards() = {
    # Harvest at certain reward threshold (thresholdSwopRewards) on swop (dapp to dapp)
    # Distribute to One Random Guy Rewards: Harvest
    if !isActive then  
        throw("DApp is inactive at this moment")
    else{
        strict x = invoke(swopFarmingContract,"claim",[toUtf8String(swopPool)],nil) # HARVEST
        let randToHigh = toInt(i.transactionId + i.callerPublicKey + lastBlock.generationSignature + toBytes(lastBlock.timestamp) + toBytes(lastBlock.height))
        let rand = randToHigh % currentUserCount
        let amount = assetBalance(dAppAddress, rewardAsset)
        if (amount >= thresholdSwopRewards) then {
            let randomFarmer = toBytes(split(currentUserList,",")[rand])
            [ScriptTransfer(Address(randomFarmer), amount, lpAsset)]
        }
        else{
            throw("Threshold not reached yet.")
        }
    }
}


@Callable(i)
func depositLPToken() = {
    let pmt = value(i.payments[0])  # all tx info    
    if !isActive then  
        throw("DApp is inactive at this moment")
    else if (pmt.assetId == lpAsset) then { # Only allow certain LP token
        let currentKey = toBase58String(i.callerPublicKey)  # determining caller key
        let currentAmount = match getInteger(this, currentKey) {  # reading current user's balance from the account state
            case a:Int => a
            case _ => 0  # taking zero as a balance value if this is the first time user deposits money
        }
        
        let newAmount = (currentAmount + pmt.amount) - (pmt.amount / 100 * depositFee)  # counting new balance as "old balance + (payment value - deposit fee)"
        strict y = invoke(swopFarmingContract,"lockShareTokens",[toUtf8String(swopPool)],[AttachedPayment(lpAsset,pmt.amount - (pmt.amount / 100 * depositFee))]) #STAKE
        if(currentUserCount <= maxPoolUsers) then {
            if(currentAmount == 0) then {
                [
                    IntegerEntry(keyUserCount, currentUserCount + 1),
                    StringEntry(keyUserList, currentUserList + "," + toBase58String(i.callerPublicKey)),
                    IntegerEntry(currentKey, newAmount), # updating user's balance in the account state
                    ScriptTransfer(addressFromPublicKey(adminPubKey),pmt.amount / 100 * depositFee,lpAsset) # that is my part of the cake (1% of all lp deposits)
                ]  
            }
            else {
                [
                    IntegerEntry(currentKey, newAmount), # updating user's balance in the account state
                    ScriptTransfer(addressFromPublicKey(adminPubKey),pmt.amount / 100 * depositFee,lpAsset) # that is my part of the cake (1% of all lp deposits)
                ]
                
            }
        }
        
        else{
            throw("Maximum allowed users:" + toString(maxPoolUsers))
        }
        
    
    }
    else {
        throw("Wrong LP token")
    }
}

@Callable(i)
func withdrawLPToken(amount: Int) = {
    
    let splittedUserList = split(currentUserList,",")
    let callerIndexUserList = match indexOf(splittedUserList,toBase58String(i.callerPublicKey))
    {
        case a:Int => splittedUserList.removeByIndex(a)
        case _ => 0 
    }
    let finalNewUserList = splittedUserList.makeString(",")
    

    # withdraw function can be invoked by user to "cash out" his lp tokens
    let currentKey = toBase58String(i.callerPublicKey) 
    let currentAmount = match getInteger(this, currentKey) {
        case a:Int => a
        case _ => 0
    }
    let newAmount = currentAmount - amount
    if !isActive then  
        throw("DApp is inactive at this moment")
    else if (amount < 0)  # is user requesting a positive amount?
        then throw("Can't withdraw negative amount")
    else if (newAmount < 0)  # does user have enough balance for this withdraw?
        then throw("Not enough balance")
    else {
        strict z = invoke(swopFarmingContract,"withdrawShareTokens",[toUtf8String(swopPool),amount],nil) #UNSTAKE
        if(newAmount == 0) then {
            [
                IntegerEntry(keyUserCount, currentUserCount - 1),
                StringEntry(keyUserList, finalNewUserList),
                IntegerEntry(currentKey, newAmount),  # saving new balance to the account state
                ScriptTransfer(i.caller, amount, lpAsset)
            ]
        }
        else{
            [
                IntegerEntry(currentKey, newAmount),  # saving new balance to the account state
                ScriptTransfer(i.caller, amount, lpAsset)
            ]
        }
    }
}

@Callable(i)
func shutdown() =
    if isDefined(isActive) then
        if(isActive == false) then
            throw("DApp is already suspended.")
        else{
            [BooleanEntry(keyActive, false)]
        }
    else if i.callerPublicKey != adminPubKey then
        throw("Only admin can call this function")
    else [BooleanEntry(keyActive, false)]

@Callable(i)
func activate() =
    if isDefined(isActive) then
        if(isActive == true) then
            throw("DApp is already active")
        else{
            [
            BooleanEntry(keyActive, true),
            IntegerEntry(keyUserCount, 0),
            StringEntry(keyUserList, "")
            ]
        }
    else if i.callerPublicKey != adminPubKey then
        throw("Only admin can call this function")
    else [
        BooleanEntry(keyActive, true),
        IntegerEntry(keyUserCount, 0),
        StringEntry(keyUserList, "")
    ]

@Verifier(tx)
func verify() = match tx {
    case _ => {
        if(adminPubKey == tx.senderPublicKey) then true else false
    }
}
